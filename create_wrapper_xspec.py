#! /usr/bin/env python3
import re
import sys

# Tool to Automatically Construct the Cpp-Model-Wrapper from the Xspec lmodel.dat file
# - models are separated by an empty line
# - for <model_name> the C-function has to be called c_<local_model_prefix><model_name>

local_model_prefix = "lmod"

header = """/*
   *** AUTOMATICALLY GENERATED: DO NOT EDIT THIS FILE ***   

   This file is part of the RELXILL model code.

   RELXILL is free software: you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   any later version.

   RELXILL is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.
   For a copy of the GNU General Public License see
   <http://www.gnu.org/licenses/>.

    Copyright 2020 Thomas Dauser, Remeis Observatory & ECAP
       
    *** AUTOMATICALLY GENERATED: DO NOT EDIT THIS FILE ***       
*/

#include "cppmodels.h"
#include "cppparameters.h"
"""


def remove_empty_strings(list_strings):
    for string in list_strings:
        if len(string) <= 1:
            list_strings.remove(string)

    return list_strings


def read_file_in_chunks(input_file):
    empty_line = '\n\n'
    with open(input_file, 'r') as reader:
        split_file = reader.read().split(empty_line)

    return remove_empty_strings(split_file)


def parse_model_name(model_definition):
    first_line = model_definition.split('\n')[0]

    res = re.match(rf'.*c_{local_model_prefix}(\w+).*', first_line)
    if res is not None:
        return res.groups()[0]
    else:
        return None


def convert_if_switch_parameter(name):
    if name[0] == '$':
        name = "switch_" + name[1:]
    return name


def parse_param_list(model_definition):
    # parameter definition starts in the second line
    param_lines = model_definition.split('\n')[1:]

    param_names = []

    for line in param_lines:
        param = line.split(' ')[0]
        if len(param) >= 1:
            param = param.lower()
            param_names.append(convert_if_switch_parameter(param))
        else:
            print(" *** error ***: could not parse the parameter in the following model definition")
            print(model_definition)
            return None

    return param_names


#
# parse the lmodel.dat file to get all defined local model names
# input:  filename for the model definition (lmodel.dat file)
# return: list of model names
def get_model_names(lmodeldat_file):
    model_definition = {}

    for single_model_definition in read_file_in_chunks(lmodeldat_file):
        model_name = parse_model_name(single_model_definition)
        if len(model_name) > 0:
            # model_list.append(model_name)

            params = parse_param_list(single_model_definition)
            #            params_list.append(params)

            model_definition[model_name] = params

            print("    - " + model_name + "  found " + str(len(params)) + " parmeters ")
        else:
            print(" *** error ***: could not parse the following model definition")
            print(single_model_definition)

    return model_definition


def get_wrapper_lmod(local_model_name):
    parameter_list = "const double *energy, int Nflux, const double *parameter, int spectrum, double *flux, double *fluxError, const char *init"
    function_call = "xspec_C_wrapper_eval_model(ModelName::" + local_model_name + ", parameter, flux, Nflux, energy);"

    c_function_name = "lmod" + local_model_name

    return f"""
extern "C" void {c_function_name}({parameter_list}) 
{{
    {function_call}
}} 
"""


def write_std_header(file):
    file.write(header)


def write_xspec_wrapper_file(outfile_name, model_names):
    file = open(outfile_name, "w")

    write_std_header(file)

    for model in model_names:
        file.write(get_wrapper_lmod(model))

    file.close()


def get_implemented_lmod(local_model_name, param_list):
    param_class = "XPar::"

    lmodel_str = \
        f"""   {{ModelName::{local_model_name},
    XspecLmodelDatDefinition(\"{local_model_name}\", {{"""

    separator = ""
    for par in param_list:
        lmodel_str += separator + param_class + par
        separator = ", "

    lmodel_str += "})\n   },\n"

    return lmodel_str


def write_xspec_implement_models(outfile_name, model_definition):
    file = open(outfile_name, "w")

    write_std_header(file)

    c_define_string = "RELXILL_XSPEC_WRAPPER_H_"
    file.write(f"#ifndef {c_define_string}\n")
    file.write(f"#define {c_define_string}\n\n")

    file.write("\nconst std::unordered_map<ModelName, XspecLmodelDatDefinition> xspec_implemented_models =  {\n")

    for model in model_definition:
        file.write(get_implemented_lmod(model, model_definition[model]))

    file.write("};\n")
    file.write(f"\n#endif //{c_define_string}")

    file.close()


if __name__ == '__main__':

    if len(sys.argv) == 3:
        input_lmodel_file = sys.argv[1]
        output_wrapper_file_cpp = sys.argv[2]
        output_wrapper_file_header = output_wrapper_file_cpp.replace(".cpp", ".h")

        print(
            f"\n *** creating {output_wrapper_file_cpp} and {output_wrapper_file_header} by parsing {input_lmodel_file}:")

        model_definition = get_model_names(input_lmodel_file)
        write_xspec_wrapper_file(output_wrapper_file_cpp, model_definition.keys())
        write_xspec_implement_models(output_wrapper_file_header, model_definition)

    else:
        print("""
    Usage: ./create_lmod_wrapper.py [lmodel.dat] [xspec_wrapper.cpp]
        """)
        exit(1)
